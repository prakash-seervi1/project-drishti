const { onRequest } = require("firebase-functions/v2/https");

// ðŸš¨ Enhanced Auto Incident Simulator with realistic patterns
module.exports = (db, corsHandler) =>
  onRequest(async (req, res) => {
    corsHandler(req, res, async () => {
      if (req.method !== "POST") {
        return res.status(405).json({ 
          success: false,
          error: "Method Not Allowed",
          timestamp: new Date().toISOString()
        });
      }

      const { 
        duration = 60, // minutes
        intensity = "normal", // low, normal, high, critical
        zones = ["Zone A", "Zone B", "Zone C"],
        incidentTypes = ["medical", "security", "fire", "crowd"],
        autoResponder = true
      } = req.body;

      console.log("Enhanced Auto Incident Simulator Request:", {
        duration,
        intensity,
        zones,
        incidentTypes,
        autoResponder
      });

      try {
        // Validate parameters
        if (duration < 1 || duration > 480) { // Max 8 hours
          return res.status(400).json({
            success: false,
            error: "Duration must be between 1 and 480 minutes",
            timestamp: new Date().toISOString()
          });
        }

        // Calculate incident schedule based on intensity
        const incidentSchedule = generateIncidentSchedule(duration, intensity, zones, incidentTypes);
        
        // Generate and create incidents
        const createdIncidents = await createIncidents(incidentSchedule, autoResponder);
        
        // Start simulation timer
        const simulationId = await startSimulation({
          duration,
          intensity,
          zones,
          incidentTypes,
          schedule: incidentSchedule,
          createdIncidents
        });

        console.log("Enhanced simulation started:", simulationId);

        return res.status(200).json({
          success: true,
          simulationId,
          incidents: createdIncidents,
          schedule: incidentSchedule,
          duration: `${duration} minutes`,
          intensity,
          timestamp: new Date().toISOString()
        });

      } catch (err) {
        console.error("Enhanced auto incident simulator error:", err);
        return res.status(500).json({ 
          success: false,
          error: "Internal server error",
          details: err.message,
          timestamp: new Date().toISOString()
        });
      }
    });
  });

// Generate realistic incident schedule
function generateIncidentSchedule(duration, intensity, zones, incidentTypes) {
  const schedule = [];
  const now = new Date();
  
  // Calculate incident frequency based on intensity
  const intensityMultipliers = {
    low: 0.5,
    normal: 1.0,
    high: 2.0,
    critical: 3.0
  };
  
  const baseFrequency = 15; // minutes between incidents for normal intensity
  const adjustedFrequency = baseFrequency / intensityMultipliers[intensity];
  
  // Calculate number of incidents
  const totalIncidents = Math.floor(duration / adjustedFrequency);
  
  // Generate incident times with some randomness
  for (let i = 0; i < totalIncidents; i++) {
    const timeOffset = (i * adjustedFrequency) + (Math.random() - 0.5) * 5; // Â±2.5 minutes randomness
    const incidentTime = new Date(now.getTime() + timeOffset * 60 * 1000);
    
    // Skip if incident time exceeds duration
    if (incidentTime.getTime() > now.getTime() + duration * 60 * 1000) {
      break;
    }
    
    const incident = {
      time: incidentTime,
      zone: zones[Math.floor(Math.random() * zones.length)],
      type: incidentTypes[Math.floor(Math.random() * incidentTypes.length)],
      priority: determinePriority(intensity, incidentTypes[Math.floor(Math.random() * incidentTypes.length)]),
      severity: determineSeverity(intensity),
      description: generateDescription(incidentTypes[Math.floor(Math.random() * incidentTypes.length)]),
      autoGenerated: true
    };
    
    schedule.push(incident);
  }
  
  // Sort by time
  schedule.sort((a, b) => a.time.getTime() - b.time.getTime());
  
  return schedule;
}

// Determine incident priority based on intensity and type
function determinePriority(intensity, incidentType) {
  const priorityMatrix = {
    low: {
      medical: 'medium',
      security: 'low',
      fire: 'high',
      crowd: 'low'
    },
    normal: {
      medical: 'medium',
      security: 'medium',
      fire: 'high',
      crowd: 'medium'
    },
    high: {
      medical: 'high',
      security: 'high',
      fire: 'critical',
      crowd: 'high'
    },
    critical: {
      medical: 'critical',
      security: 'critical',
      fire: 'critical',
      crowd: 'critical'
    }
  };
  
  return priorityMatrix[intensity]?.[incidentType] || 'medium';
}

// Determine incident severity
function determineSeverity(intensity) {
  const severityRanges = {
    low: [1, 2],
    normal: [2, 3],
    high: [3, 4],
    critical: [4, 5]
  };
  
  const [min, max] = severityRanges[intensity] || [2, 3];
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Generate realistic incident descriptions
function generateDescription(incidentType) {
  const descriptions = {
    medical: [
      "Person reported feeling unwell",
      "Minor injury requiring attention",
      "Medical emergency reported",
      "Person collapsed",
      "Allergic reaction reported"
    ],
    security: [
      "Suspicious activity reported",
      "Unauthorized access attempt",
      "Disturbance in progress",
      "Security breach detected",
      "Aggressive behavior reported"
    ],
    fire: [
      "Smoke detected",
      "Fire alarm triggered",
      "Small fire reported",
      "Electrical malfunction",
      "Fire hazard identified"
    ],
    crowd: [
      "Crowd surge detected",
      "Overcrowding reported",
      "Crowd control needed",
      "Stampede risk identified",
      "Crowd disturbance"
    ]
  };
  
  const typeDescriptions = descriptions[incidentType] || ["Incident reported"];
  return typeDescriptions[Math.floor(Math.random() * typeDescriptions.length)];
}

// Create incidents in database
async function createIncidents(schedule, autoResponder) {
  const createdIncidents = [];
  
  for (const incident of schedule) {
    try {
      const incidentData = {
        type: incident.type,
        zone: incident.zone,
        priority: incident.priority,
        severity: incident.severity,
        description: incident.description,
        status: 'reported',
        timestamp: incident.time,
        autoGenerated: true,
        source: 'Auto Incident Simulator',
        lastUpdated: new Date()
      };
      
      // Add to database (simulated for now)
      const incidentId = `sim_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      incidentData.id = incidentId;
      
      // Auto-assign responder if enabled
      if (autoResponder) {
        const responder = await findAvailableResponder(incident.type, incident.zone);
        if (responder) {
          incidentData.assignedResponder = {
            id: responder.id,
            name: responder.name,
            type: responder.type,
            assignedAt: new Date()
          };
          incidentData.status = 'assigned';
        }
      }
      
      createdIncidents.push(incidentData);
      
      console.log(`Created simulated incident: ${incidentId} - ${incident.type} in ${incident.zone}`);
      
    } catch (error) {
      console.error("Error creating incident:", error);
    }
  }
  
  return createdIncidents;
}

// Find available responder for incident
async function findAvailableResponder(incidentType, zone) {
  try {
    // This would typically query the responders collection
    // For now, return mock responder
    const mockResponders = [
      {
        id: 'resp_001',
        name: 'John Smith',
        type: 'medical',
        status: 'available',
        zone: 'Zone A'
      },
      {
        id: 'resp_002',
        name: 'Sarah Johnson',
        type: 'security',
        status: 'available',
        zone: 'Zone B'
      },
      {
        id: 'resp_003',
        name: 'Mike Wilson',
        type: 'fire',
        status: 'available',
        zone: 'Zone C'
      }
    ];
    
    const suitableResponder = mockResponders.find(responder => 
      responder.status === 'available' && 
      (responder.type === incidentType || responder.type === 'emergency') &&
      (responder.zone === zone || !responder.zone)
    );
    
    return suitableResponder || null;
    
  } catch (error) {
    console.error("Error finding available responder:", error);
    return null;
  }
}

// Start simulation and schedule incidents
async function startSimulation(simulationConfig) {
  try {
    const simulationId = `sim_${Date.now()}`;
    
    // Create simulation record
    const simulationRecord = {
      id: simulationId,
      status: 'running',
      startTime: new Date(),
      config: simulationConfig,
      incidentsCreated: simulationConfig.createdIncidents.length,
      lastUpdate: new Date()
    };
    
    console.log(`Simulation ${simulationId} started with ${simulationConfig.createdIncidents.length} incidents`);
    
    // Schedule incident creation
    simulationConfig.schedule.forEach((incident, index) => {
      const delay = incident.time.getTime() - Date.now();
      
      if (delay > 0) {
        setTimeout(async () => {
          try {
            await createScheduledIncident(incident, simulationId);
            console.log(`Scheduled incident ${index + 1} created for ${incident.zone}`);
          } catch (error) {
            console.error(`Error creating scheduled incident ${index + 1}:`, error);
          }
        }, delay);
      }
    });
    
    // Schedule simulation end
    setTimeout(async () => {
      try {
        await endSimulation(simulationId);
        console.log(`Simulation ${simulationId} completed`);
      } catch (error) {
        console.error(`Error ending simulation ${simulationId}:`, error);
      }
    }, simulationConfig.duration * 60 * 1000);
    
    return simulationId;
    
  } catch (error) {
    console.error("Error starting simulation:", error);
    throw error;
  }
}

// Create scheduled incident
async function createScheduledIncident(incident, simulationId) {
  try {
    const incidentData = {
      type: incident.type,
      zone: incident.zone,
      priority: incident.priority,
      severity: incident.severity,
      description: incident.description,
      status: 'reported',
      timestamp: new Date(),
      autoGenerated: true,
      source: 'Auto Incident Simulator',
      simulationId,
      lastUpdated: new Date()
    };
    
    // Add to database (simulated)
    const incidentId = `sim_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    incidentData.id = incidentId;
    
    console.log(`Scheduled incident created: ${incidentId}`);
    return incidentData;
    
  } catch (error) {
    console.error("Error creating scheduled incident:", error);
    throw error;
  }
}

// End simulation
async function endSimulation(simulationId) {
  try {
    console.log(`Ending simulation: ${simulationId}`);
    
    // Update simulation record
    const simulationRecord = {
      status: 'completed',
      endTime: new Date(),
      lastUpdate: new Date()
    };
    
    console.log(`Simulation ${simulationId} ended successfully`);
    
  } catch (error) {
    console.error("Error ending simulation:", error);
    throw error;
  }
} 