# -*- coding: utf-8 -*-
"""orchestrator_chatBotHackethon.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SgMPdIQwebGRNkvbxC4LWC_edPgpKvhX
"""

!pip install google-adk

import asyncio
import os
import json
import time
from typing import Dict, List, Any, Optional
from datetime import datetime
import requests
from google.adk.agents import LoopAgent, LlmAgent, SequentialAgent
from google.adk.runners import Runner, InMemorySessionService
from google.adk.tools.tool_context import ToolContext
from google.genai.types import Content, Part
import google.generativeai as genai

# Configure API Key
try:
    GOOGLE_API_KEY = os.getenv('GOOGLE_API_KEY')
    WEATHER_API_KEY = os.getenv('WEATHER_API_KEY')

    if not GOOGLE_API_KEY:
        raise ValueError("GOOGLE_API_KEY environment variable not set")

    genai.configure(api_key=GOOGLE_API_KEY)
    os.environ['GOOGLE_API_KEY'] = GOOGLE_API_KEY
    print("âœ… Google AI API Key configured successfully.")
except Exception as e:
    print(f"âŒ Error setting up API Key: {e}")
    raise

# --- Mock Database Implementation ---
class MockFirestoreDB:
    """Mock implementation of Firestore database for demonstration"""
    def __init__(self):
        self.incidents = [
            {"id": "INC001", "timestamp": datetime.now().isoformat(), "zone": "Zone A", "type": "medical", "status": "active", "severity": "medium", "description": "Minor injury at food court"},
            {"id": "INC002", "timestamp": datetime.now().isoformat(), "zone": "Zone B", "type": "crowd", "status": "resolved", "severity": "high", "description": "Overcrowding near main stage"},
            {"id": "INC003", "timestamp": datetime.now().isoformat(), "zone": "Zone A", "type": "security", "status": "active", "severity": "low", "description": "Lost child reported"}
        ]
        self.responders = [
            {"id": "RESP001", "name": "Dr. Sarah Johnson", "type": "medical", "status": "available", "zone": "Zone A", "contact": "med-001"},
            {"id": "RESP002", "name": "Officer Mike Davis", "type": "security", "status": "busy", "zone": "Zone B", "contact": "sec-001"},
            {"id": "RESP003", "name": "Paramedic Team Alpha", "type": "medical", "status": "available", "zone": "Zone C", "contact": "med-002"}
        ]
        self.zones = [
            {"id": "ZONE001", "name": "Zone A", "capacity": 5000, "current_occupancy": 3200, "risk_level": "medium", "facilities": ["medical_station", "security_booth"]},
            {"id": "ZONE002", "name": "Zone B", "capacity": 8000, "current_occupancy": 7500, "risk_level": "high", "facilities": ["main_stage", "food_court"]},
            {"id": "ZONE003", "name": "Zone C", "capacity": 3000, "current_occupancy": 1800, "risk_level": "low", "facilities": ["parking", "entrance"]}
        ]

# Initialize mock database
db = MockFirestoreDB()

# --- Constants ---
APP_NAME = "event_safety_orchestrator"
USER_ID = "safety_coordinator"
GEMINI_MODEL = "gemini-2.5-flash"
GEMINI_PRO_MODEL = "gemini-2.5-pro"

# State Keys
STATE_USER_QUERY = "user_query"
STATE_ANALYSIS_DATA = "analysis_data"
STATE_FINAL_RESPONSE = "final_response"

# --- Tool Functions ---
def get_incident_data(tool_context: ToolContext, limit: int = 30, zone: Optional[str] = None):
    """Get recent incidents from the database"""
    print(f"  [Tool Call] get_incident_data called by '{tool_context.agent_name}' with limit={limit}, zone={zone}")
    try:
        incidents = db.incidents.copy()
        if zone:
            incidents = [inc for inc in incidents if inc.get('zone') == zone]
        result = {"incidents": incidents[:limit], "count": len(incidents)}
        print(f"  [Tool Result] Found {len(incidents)} incidents")
        return result
    except Exception as e:
        print(f"  [Tool Error] get_incident_data failed: {e}")
        return {"incidents": [], "count": 0, "error": str(e)}

def get_responder_data(tool_context: ToolContext, status: str = "available", resp_type: Optional[str] = None, zone: Optional[str] = None):
    """Get available responders from the database"""
    print(f"  [Tool Call] get_responder_data called by '{tool_context.agent_name}' with status={status}, type={resp_type}, zone={zone}")
    try:
        responders = db.responders.copy()
        if status:
            responders = [resp for resp in responders if resp.get('status') == status]
        if resp_type:
            responders = [resp for resp in responders if resp.get('type') == resp_type]
        if zone:
            responders = [resp for resp in responders if resp.get('zone') == zone]
        result = {"responders": responders, "count": len(responders)}
        print(f"  [Tool Result] Found {len(responders)} responders")
        return result
    except Exception as e:
        print(f"  [Tool Error] get_responder_data failed: {e}")
        return {"responders": [], "count": 0, "error": str(e)}

def get_zone_data(tool_context: ToolContext, zone_name: Optional[str] = None):
    """Get zone information from the database"""
    print(f"  [Tool Call] get_zone_data called by '{tool_context.agent_name}' with zone_name={zone_name}")
    try:
        zones = db.zones.copy()
        if zone_name:
            zones = [zone for zone in zones if zone.get('name') == zone_name]
        result = {"zones": zones, "count": len(zones)}
        print(f"  [Tool Result] Found {len(zones)} zones")
        return result
    except Exception as e:
        print(f"  [Tool Error] get_zone_data failed: {e}")
        return {"zones": [], "count": 0, "error": str(e)}

def get_weather_data(tool_context: ToolContext, location: str = "EventCity"):
    """Get current weather information"""
    print(f"  [Tool Call] get_weather_data called by '{tool_context.agent_name}' with location={location}")
    try:
        if WEATHER_API_KEY:
            url = f"https://api.openweathermap.org/data/2.5/weather?q={location}&appid={WEATHER_API_KEY}&units=metric"
            response = requests.get(url, timeout=10)
            weather_data = response.json()
            return {"weather": weather_data, "location": location, "status": "success"}
        else:
            return {
                "weather": {"weather": [{"main": "Clear", "description": "clear sky"}], "main": {"temp": 25, "humidity": 60}, "wind": {"speed": 5.5}},
                "location": location,
                "status": "mock_data"
            }
    except Exception as e:
        print(f"  [Tool Error] Weather API call failed: {e}")
        return {"weather": None, "location": location, "status": "error", "error": str(e)}

def analyze_situation(tool_context: ToolContext, zone: Optional[str] = None):
    """Analyze the current situation based on gathered data"""
    print(f"  [Tool Call] analyze_situation called by '{tool_context.agent_name}' with zone={zone}")

    try:
        # Collect all data
        incident_data = get_incident_data(tool_context, zone=zone)
        responder_data = get_responder_data(tool_context, zone=zone)
        zone_data = get_zone_data(tool_context, zone_name=zone)
        weather_data = get_weather_data(tool_context)

        # Process data
        active_incidents = [inc for inc in incident_data['incidents'] if inc.get('status') == 'active']
        available_responders = responder_data['responders']

        weather_condition = "Unknown"
        if weather_data.get('weather') and weather_data['weather'].get('weather'):
            weather_condition = weather_data['weather']['weather'][0].get('main', 'Unknown')

        analysis = {
            "timestamp": datetime.now().isoformat(),
            "active_incidents": len(active_incidents),
            "total_incidents": len(incident_data['incidents']),
            "available_responders": len(available_responders),
            "weather_condition": weather_condition,
            "zone": zone if zone else "all zones",
            "risk_level": "high" if len(active_incidents) > 2 else "medium" if len(active_incidents) > 0 else "low",
            "recommendations": [
                f"Increase security patrols in {zone}" if zone else "Monitor all zones",
                "Ensure medical staff are on standby",
                "Monitor weather conditions"
            ]
        }

        result = {
            "analysis": analysis,
            "incident_data": incident_data,
            "responder_data": responder_data,
            "zone_data": zone_data,
            "weather_data": weather_data
        }

        print(f"  [Tool Result] Analysis complete - Risk level: {analysis['risk_level']}")
        return result
    except Exception as e:
        print(f"  [Tool Error] analyze_situation failed: {e}")
        return {"analysis": {"error": str(e)}, "incident_data": {}, "responder_data": {}, "zone_data": {}, "weather_data": {}}

def finalize_response(tool_context: ToolContext, response_text: str = ""):
    """Call this function when the final response is ready"""
    print(f"  [Tool Call] finalize_response triggered by '{tool_context.agent_name}'. Response finalized!")

    # Store the response in the tool context state
    if hasattr(tool_context, 'state') and tool_context.state:
        tool_context.state[STATE_FINAL_RESPONSE] = response_text

    # Set escalate to signal completion
    tool_context.actions.escalate = True
    return {"status": "finalized", "response": response_text}

# --- Agent Definitions ---
# Data Collector Agent - Only makes one function call
data_collector_agent = LlmAgent(
    name="DataCollectorAgent",
    model=GEMINI_MODEL,
    instruction="""You are a safety data collection specialist. Analyze the user query and call ONE appropriate function to gather the required data.

User Query: {user_query}

Available functions:
- analyze_situation: For comprehensive analysis (use 'zone' parameter if a specific zone is mentioned)
- get_incident_data: Only if specifically asked for incidents
- get_responder_data: Only if specifically asked for personnel
- get_zone_data: Only if specifically asked for zone info
- get_weather_data: Only if specifically asked for weather

Call ONLY ONE function per execution. For general situation queries, always use analyze_situation.

After calling the function, summarize what data was collected and pass it to the next agent.""",
    tools=[analyze_situation, get_incident_data, get_responder_data, get_zone_data, get_weather_data],
    output_key=STATE_ANALYSIS_DATA
)

# Response Generator Agent - Only makes finalize call
response_generator_agent = LlmAgent(
    name="ResponseGeneratorAgent",
    model=GEMINI_PRO_MODEL,
    instruction="""You are an expert safety coordinator. Create a comprehensive response based on the collected data.

User Query: {user_query}
Collected Data: {analysis_data}

Structure your response with:
1. Summary of current situation
2. Key findings from data
3. Safety recommendations
4. Next steps

Be specific and actionable. When your response is complete, call finalize_response with your full response text.""",
    tools=[finalize_response],
    output_key=STATE_FINAL_RESPONSE
)

# Create the Pipeline
root_agent = SequentialAgent(
    name="EventSafetyOrchestrator",
    sub_agents=[data_collector_agent, response_generator_agent]
)

print(f"âœ… Event Safety Orchestrator '{root_agent.name}' created successfully.")

# --- Setup Session Service and Runner ---
session_service = InMemorySessionService()
runner = Runner(
    agent=root_agent,
    app_name=APP_NAME,
    session_service=session_service
)

print(f"âœ… Runner created for agent '{runner.agent.name}'.")

# --- Main Processing Function ---
async def process_safety_query(user_query: str):
    """Process a safety query through the AI orchestrator"""
    session_id = f"safety_query_{int(time.time())}"
    print("-" * 70)
    print(f"\nğŸ¯ Processing Safety Query: {user_query}")
    print(f"   Session ID: {session_id}")
    print(f"   Timestamp: {datetime.now().isoformat()}")
    print("-" * 70)

    initial_state = {STATE_USER_QUERY: user_query}

    try:
        session = await session_service.create_session(
            app_name=APP_NAME,
            user_id=USER_ID,
            session_id=session_id,
            state=initial_state
        )
        print(f"âœ… Session created successfully: {session_id}")
    except Exception as e:
        print(f"âŒ Failed to create session: {e}")
        return {
            'query': user_query,
            'response': f"Failed to create session: {str(e)}",
            'session_id': session_id,
            'timestamp': datetime.now().isoformat()
        }

    # Create initial message as user role
    initial_message = Content(
        role="user",
        parts=[Part(text=f"Process this safety query: {user_query}")]
    )

    final_response = "Query processing failed."
    event_count = 0

    # Process through the pipeline
    try:
        print(f"ğŸ”„ Starting pipeline execution...")

        async for event in runner.run_async(
            user_id=USER_ID,
            session_id=session_id,
            new_message=initial_message
        ):
            event_count += 1
            print(f"  [Event #{event_count}] From: {event.author}")

            if event.content and event.content.parts:
                content_text = ""
                for part in event.content.parts:
                    if hasattr(part, 'text') and part.text:
                        content_text = part.text.strip()
                        print(f"  >> Text: \"{content_text[:150]}{'...' if len(content_text) > 150 else ''}\"")
                    elif hasattr(part, 'function_call') and part.function_call:
                        func_name = part.function_call.name
                        print(f"  >> Function Call: {func_name}")
                        content_text = f"[Function Call: {func_name}]"

            # Check for escalation (completion signal)
            if event.actions and event.actions.escalate:
                print("  >> Action: Pipeline escalated - processing complete!")
                break

            # Safety check - prevent infinite loops
            if event_count > 20:
                print("  >> Warning: Too many events, breaking loop")
                break

        print(f"ğŸ Pipeline execution completed after {event_count} events")

        # Get final response from session
        try:
            final_session = await session_service.get_session(
                app_name=APP_NAME,
                user_id=USER_ID,
                session_id=session_id
            )

            if final_session and final_session.state:
                print(f"ğŸ“Š Final session state keys: {list(final_session.state.keys())}")

                if STATE_FINAL_RESPONSE in final_session.state:
                    final_response = final_session.state[STATE_FINAL_RESPONSE]
                    print(f"âœ… Found final response in session state")
                elif STATE_ANALYSIS_DATA in final_session.state:
                    # If we have analysis data but no final response, use that
                    analysis_data = final_session.state[STATE_ANALYSIS_DATA]
                    final_response = f"Analysis completed: {str(analysis_data)[:200]}..."
                    print(f"âš ï¸  Using analysis data as fallback response")
                else:
                    print(f"âŒ No final response found in session state")
            else:
                print(f"âŒ Failed to retrieve final session or session has no state")

        except Exception as e:
            print(f"âŒ Error retrieving final session: {e}")

    except Exception as e:
        print(f"âŒ Pipeline execution error: {e}")
        import traceback
        traceback.print_exc()
        final_response = f"Error processing query: {str(e)}"

    print(f"\nâœ… Final Response Length: {len(final_response)} characters")
    print(f"ğŸ“‹ Response Preview: {final_response[:200]}{'...' if len(final_response) > 200 else ''}")
    print("-" * 70)

    return {
        'query': user_query,
        'response': final_response,
        'session_id': session_id,
        'timestamp': datetime.now().isoformat()
    }

# --- Test Queries ---
sample_queries = [
    "What's the current situation in Zone A?",
    "Are there any active incidents?",
    "What's the weather forecast?"
]

# --- Process Multiple Queries ---
async def process_multiple_queries():
    print("\nğŸš€ Starting Event Safety Orchestrator Pipeline...")
    print("=" * 80)
    results = []

    for i, query in enumerate(sample_queries, 1):
        try:
            print(f"\nğŸ” Processing query {i}/{len(sample_queries)}: {query}")
            result = await process_safety_query(query)
            results.append(result)

            # Add a small delay between queries
            await asyncio.sleep(1)

        except Exception as e:
            print(f"âŒ Error processing query '{query}': {e}")
            import traceback
            traceback.print_exc()
            results.append({
                'query': query,
                'response': f"Error: {e}",
                'session_id': None,
                'timestamp': datetime.now().isoformat()
            })

    # Display summary
    print("\n" + "=" * 80)
    print("ğŸ‰ SAFETY ORCHESTRATOR PIPELINE COMPLETE!")
    print("=" * 80)

    for i, result in enumerate(results, 1):
        print(f"\nğŸ“ Result {i}:")
        print(f"â“ Query: {result['query']}")
        print(f"ğŸ“‹ Response: {result['response'][:300]}{'...' if len(result['response']) > 300 else ''}")
        print(f"ğŸ• Timestamp: {result['timestamp']}")
        print(f"ğŸ†” Session: {result['session_id']}")

    success_count = len([r for r in results if not r['response'].startswith('Error')])
    print(f"\nâœ… Successfully processed {success_count}/{len(results)} safety queries!")
    return results

# --- Main Execution ---
async def main():
    return await process_multiple_queries()

if __name__ == "__main__":
    print("\nğŸ Starting Event Safety AI Orchestrator...")
    result = await main()
    print(f"\nğŸ¯ Execution complete! Processed {len(result)} queries.")