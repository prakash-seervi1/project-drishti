const { onObjectFinalized } = require("firebase-functions/v2/storage");
const { logger } = require("firebase-functions");
const { Storage } = require("@google-cloud/storage");
const sharp = require("sharp");

const storage = new Storage();

const waitOneMinute = () => new Promise(resolve => setTimeout(resolve, 60000));


module.exports = (db, geminiModel) =>
  onObjectFinalized(
    {
      bucket: "project-drishti-central1-bucket", // ‚úÖ Ensure this is correct
      memory: "4GiB",
      timeoutSeconds: 540,
    },
    async (event) => {
      try {

        console.log("‚è≥ Waiting for 1 minute...");
        await waitOneMinute();
        console.log("‚úÖ Done waiting!");

        const object = event.data;
        const filePath = object.name;
        const bucketName = object.bucket;
        const mimeType = object.contentType;

        logger.log(`üì¶ New file uploaded: ${filePath}`);

        if (
          !mimeType ||
          (!mimeType.startsWith("image/jpeg") && !mimeType.startsWith("image/png"))
        ) {
          logger.log(`‚ö†Ô∏è Skipping unsupported file: ${filePath}`);
          return;
        }

        // üîç Find metadata in Firestore
        const mediaSnapshot = await db
          .collection("media")
          .where("objectPath", "==", filePath)
          .get();

        if (mediaSnapshot.empty) {
          logger.log(`‚ö†Ô∏è No Firestore doc found for ${filePath}`);
          return;
        }

        const mediaDoc = mediaSnapshot.docs[0];
        const mediaData = mediaDoc.data();
        const zone = mediaData.zone || "Unknown";
      const publicImageUrl = "https://storage.googleapis.com/project-drishti-central1-bucket/uploads/9c59ae96-8935-40d9-bc86-1b4f02524c05_360_F_691406423_GsaWMMEYx41MpaVkENKYSNVfuSQ3JhWH.jpg"//mediaData.fileUrl
        const ZONE_CAPACITY = {
          "Zone A": 100,
          "Zone B": 300,
          "Zone C": 50,
        };
        const zoneLimit = ZONE_CAPACITY[zone] || 100;

        // üñºÔ∏è Download + resize image
        const file = storage.bucket(bucketName).file(filePath);
        const [originalBuffer] = await file.download();
        const resizedBuffer = await sharp(originalBuffer)
          .resize({ width: 512 }) // üìè Resize to reduce token size
          .jpeg({ quality: 80 }) // üßº Compress if needed
          .toBuffer();

        const base64Image = resizedBuffer.toString("base64");

        const prompt = `Analyze the crowd in this image and return ONLY this JSON:
{
  "peopleCount": <number>,
  "crowdDensity": "low|moderate|high",
  "suggestedAction": "<string>"
}
The capacity limit for this zone is ${zoneLimit}.`;

        logger.log("üì® Gemini Prompt:", prompt.substring(0, 100));

        const response = await geminiModel.generateContent({
          contents: [
            {
              role: "user",
              parts: [
                { text: prompt },
                // {"file_data": {"mime_type": mimeType, "file_uri": publicImageUrl}}
                {
                  inlineData: {
                    mimeType,
                    data: base64Image,
                  },
                },
              ],
            },
          ],
          generationConfig: {
            maxOutputTokens: null,
            temperature: 0.2,
            responseMimeType: "application/json",
          },
        });

        logger.log("üì® Gemini raw response:", JSON.stringify(response));

        const text =
          response?.response?.candidates?.[0]?.content?.parts?.[0]?.text || "";

        let peopleCount = 0;
        let crowdDensity = "low";
        let suggestedAction = "No action needed";

        try {
          const json = JSON.parse(text);
          peopleCount = json.peopleCount ?? 0;
          crowdDensity = json.crowdDensity ?? "low";
          suggestedAction = json.suggestedAction ?? suggestedAction;
        } catch (err) {
          logger.error("‚ö†Ô∏è Failed to parse Gemini response JSON", err.message);
          return;
        }

        await mediaDoc.ref.update({
          peopleCount,
          crowdDensity,
          suggestedAction,
          analyzedAt: new Date(),
        });

        if (crowdDensity === "high") {
          await db.collection("incidents").add({
            type: "Crowd Surge",
            status: "Ongoing",
            zone,
            source: "Gemini Vision",
            responderType: "Crowd Control",
            peopleCount,
            timestamp: new Date(),
            autoGenerated: true,
          });
          logger.log(`üö® Incident created for ${zone}`);
        }

        logger.log(
          `‚úÖ Crowd analysis complete: ${peopleCount} people, density=${crowdDensity}`
        );
      } catch (err) {
        logger.error("‚ùå Gemini analysis failed", err);
      }
    }
  );
